<!DOCTYPE html>
<html>
    <head>
        <style>
            /* basic reset */
            * {
                margin: 0;
                padding: 0;
            }

            body {
                background: black;
                overflow: hidden;
                height: 100vh;
                font-family: monospace;
                color: #0F0;
            }

            canvas {
                display: block;
                position: absolute;
                top: 0;
                left: 0;
            }

            #videoCanvas {
                z-index: 10;
                /* Скрываем видео полностью */
                display: none;
            }

            #matrixCanvas {
                z-index: 20;
            }

            #silhouetteCanvas {
                z-index: 30;
                /* Полностью прозрачный холст для силуэта */
                opacity: 1;
                pointer-events: none;
            }

            #cameraButton {
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px 20px;
                background-color: rgba(0, 50, 0, 0.7);
                color: #0F0;
                border: 1px solid #0F0;
                cursor: pointer;
                z-index: 40;
                font-family: monospace;
                font-size: 16px;
                border-radius: 5px;
            }

            #cameraButton:hover {
                background-color: rgba(0, 80, 0, 0.9);
            }

            #message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #0F0;
                font-size: 24px;
                text-align: center;
                z-index: 40;
                padding: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                border: 1px solid #0F0;
                display: none;
                max-width: 80%;
            }
        </style>
    </head>
    <body>
        <canvas id="videoCanvas"></canvas>
        <canvas id="matrixCanvas"></canvas>
        <canvas id="silhouetteCanvas"></canvas>
        <button id="cameraButton">Включить камеру</button>
        <div id="message">Нажмите "Разрешить" в запросе камеры для продолжения</div>

        <script>
        // Основные элементы
        const matrixCanvas = document.getElementById("matrixCanvas");
        const matrixCtx = matrixCanvas.getContext("2d");
        const videoCanvas = document.getElementById("videoCanvas");
        const videoCtx = videoCanvas.getContext("2d");
        const silhouetteCanvas = document.getElementById("silhouetteCanvas");
        const silhouetteCtx = silhouetteCanvas.getContext("2d");
        const cameraButton = document.getElementById("cameraButton");
        const messageDiv = document.getElementById("message");

        // Настройки канваса
        matrixCanvas.width = videoCanvas.width = silhouetteCanvas.width = window.innerWidth;
        matrixCanvas.height = videoCanvas.height = silhouetteCanvas.height = window.innerHeight;

        // Настройки видео
        let video;
        let silhouetteData;
        let cameraActive = false;
        const silhouetteThreshold = 100; // Повышенный порог для светлых областей

        // Настройки матрицы
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン";
        const charactersArray = characters.split("");
        const fontSize = 12; // Уменьшаем размер шрифта для более плотного отображения
        const columns = Math.ceil(matrixCanvas.width/fontSize);
        const rows = Math.ceil(matrixCanvas.height/fontSize);

        // Отдельные символы для силуэта - только числа и буквы X для более чёткого эффекта
        const silhouetteChars = "01X3456789X";
        const silhouetteCharsArray = silhouetteChars.split("");

        // Капли дождя
        let drops = [];
        for(let x = 0; x < columns; x++) {
            drops[x] = 1;
        }

        // Слово INNOFORCE
        const word = "INNOFORCE";
        let wordPositions = [];
        let mode = "rain";
        let modeStartTime = Date.now();
        const formationDuration = 2000;
        const showDuration = 3000;
        const dissolveDuration = 2000;
        const rainDuration = 5000;

        // Матрица силуэта - будет содержать символы для отображения
        let silhouetteMatrix = Array(rows * columns).fill(null);
        
        // Дождь из силуэта - теперь используем тот же механизм что и для основного дождя
        let silhouetteDrops = [];
        for(let x = 0; x < columns; x++) {
            silhouetteDrops[x] = 0; // начинаем с 0, чтобы сразу появились
        }

        // Инициализация камеры
        cameraButton.addEventListener("click", startCamera);

        function startCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                messageDiv.style.display = "block";

                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(function(stream) {
                        messageDiv.style.display = "none";
                        cameraButton.textContent = "Отключить камеру";
                        cameraButton.removeEventListener("click", startCamera);
                        cameraButton.addEventListener("click", stopCamera);

                        video = document.createElement('video');
                        video.srcObject = stream;
                        video.play();

                        cameraActive = true;

                        // Создаем массив для хранения силуэта
                        silhouetteData = new Uint8Array(columns * rows);
                    })
                    .catch(function(error) {
                        console.error("Камера не доступна: ", error);
                        messageDiv.textContent = "Доступ к камере не получен. Пожалуйста, разрешите доступ к камере и попробуйте снова.";
                        setTimeout(() => {
                            messageDiv.style.display = "none";
                        }, 3000);
                    });
            } else {
                messageDiv.textContent = "Камера не поддерживается в вашем браузере.";
                messageDiv.style.display = "block";
                setTimeout(() => {
                    messageDiv.style.display = "none";
                }, 3000);
            }
        }

        function stopCamera() {
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                cameraActive = false;
                cameraButton.textContent = "Включить камеру";
                cameraButton.removeEventListener("click", stopCamera);
                cameraButton.addEventListener("click", startCamera);

                // Очистить видео канвас и силуэт
                videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
                silhouetteCtx.clearRect(0, 0, silhouetteCanvas.width, silhouetteCanvas.height);
                silhouetteMatrix = Array(rows * columns).fill(null);
                
                // Сбросить силуэтные капли
                for(let x = 0; x < columns; x++) {
                    silhouetteDrops[x] = 0; 
                }
            }
        }

        // Рассчитываем позиции для слова
        function calculateWordPositions() {
            const wordWidth = word.length * fontSize;
            const startX = Math.floor((matrixCanvas.width - wordWidth) / 2 / fontSize);
            const centerY = Math.floor(matrixCanvas.height / 2 / fontSize);

            wordPositions = [];
            for (let i = 0; i < word.length; i++) {
                wordPositions.push({
                    x: startX + i,
                    y: centerY,
                    letter: word[i],
                    originalX: startX + i,
                    originalY: centerY,
                    // Для анимации формирования - начинаем с верхней части экрана
                    startX: startX + i, // Теперь буквы падают сверху, начиная с правильной Х-позиции
                    startY: -5 - Math.floor(Math.random() * 10), // Разные высоты для каждой буквы
                    progress: 0
                });
            }
        }

        // Обработка видео для создания силуэта
        function processVideo() {
            if (!cameraActive || !video) return;

            // Рисуем видео на скрытом канвасе
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;

            if (videoWidth && videoHeight) {
                // Расчет размера и положения для сохранения пропорций
                // Возвращаем max для заполнения всего экрана
                const scale = Math.max(
                    videoCanvas.width / videoWidth,
                    videoCanvas.height / videoHeight
                );

                // Центрирование видео
                const x = (videoCanvas.width - videoWidth * scale) / 2;
                // Немного сдвигаем видео вверх, чтобы нижняя часть не обрезалась
                const y = (videoCanvas.height - videoHeight * scale) / 2 - 20;

                // Очистка канваса
                videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);

                // Отразить видео как зеркало с увеличением контраста
                videoCtx.save();
                videoCtx.translate(videoCanvas.width, 0);
                videoCtx.scale(-1, 1);
                videoCtx.drawImage(
                    video,
                    0, 0, videoWidth, videoHeight,
                    videoCanvas.width - videoWidth * scale - x, y, videoWidth * scale, videoHeight * scale
                );

                // Добавим контраст для лучшего обнаружения светлых областей
                videoCtx.globalCompositeOperation = 'source-atop';
                videoCtx.fillStyle = 'rgba(255, 255, 255, 0.2)'; // Увеличиваем контраст
                videoCtx.fillRect(0, 0, videoCanvas.width, videoCanvas.height);
                videoCtx.globalCompositeOperation = 'source-over';

                videoCtx.restore();

                // Получаем данные пикселей
                const imageData = videoCtx.getImageData(0, 0, videoCanvas.width, videoCanvas.height);
                const pixels = imageData.data;

                // Очищаем матрицу силуэта
                silhouetteMatrix = Array(rows * columns).fill(null);

                // Пониженный порог для силуэта, чтобы захватить больше деталей
                const loweredThreshold = silhouetteThreshold * 0.8;

                // Обновляем силуэт - ищем светлые области
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < columns; x++) {
                        // Исходный пиксель для этой ячейки матрицы
                        const pixelX = Math.floor(x * fontSize);
                        const pixelY = Math.floor(y * fontSize);

                        if (pixelX < videoCanvas.width && pixelY < videoCanvas.height) {
                            const i = (pixelY * videoCanvas.width + pixelX) * 4;

                            // Яркость пикселя (простой расчет)
                            const brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;

                            // Если яркость ВЫШЕ порога - считаем что это часть силуэта (светлые области)
                            if (brightness > loweredThreshold) {
                                silhouetteData[y * columns + x] = 1;

                                // Создаем случайный символ для силуэта
                                const charIndex = Math.floor(Math.random() * silhouetteCharsArray.length);
                                silhouetteMatrix[y * columns + x] = silhouetteCharsArray[charIndex];
                            } else {
                                silhouetteData[y * columns + x] = 0;
                            }
                        }
                    }
                }
            }
        }

        // Главная функция отрисовки
        function draw() {
            // Проверяем смену режимов
            const currentTime = Date.now();
            const elapsed = currentTime - modeStartTime;

            if (mode === "rain" && elapsed >= rainDuration) {
                mode = "forming";
                modeStartTime = currentTime;
                calculateWordPositions();
            } else if (mode === "forming" && elapsed >= formationDuration) {
                mode = "showing";
                modeStartTime = currentTime;
            } else if (mode === "showing" && elapsed >= showDuration) {
                mode = "dissolving";
                modeStartTime = currentTime;
            } else if (mode === "dissolving" && elapsed >= dissolveDuration) {
                mode = "rain";
                modeStartTime = currentTime;
            }

            // Обрабатываем видео, если камера активна
            if (cameraActive) {
                processVideo();
            }

            // Затемняем фон для эффекта следа
            matrixCtx.fillStyle = "rgba(0, 0, 0, 0.1)";
            matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

            matrixCtx.font = fontSize + "px monospace";

            // Отрисовка в зависимости от режима
            if (mode === "rain") {
                drawRain();
            } else if (mode === "forming") {
                drawForming(elapsed / formationDuration);
            } else if (mode === "showing") {
                drawWord();
            } else if (mode === "dissolving") {
                drawDissolving(elapsed / dissolveDuration);
            }

            // Отрисовываем силуэт с эффектом дождя
            if (cameraActive) {
                drawSilhouette();
            }
        }

        // Отрисовка силуэта с эффектом матричного дождя
        function drawSilhouette() {
            if (!cameraActive) return;

            silhouetteCtx.clearRect(0, 0, silhouetteCanvas.width, silhouetteCanvas.height);
            silhouetteCtx.font = "bold " + fontSize + "px monospace";
            silhouetteCtx.fillStyle = "#0F0"; // Яркий зеленый цвет для силуэта

            // Проходим по всем колонкам для рисования дождя
            for (let x = 0; x < columns; x++) {
                // В каждой колонке нам нужно определить "светлые" области силуэта
                const silhouettePositions = [];
                
                // Собираем все позиции силуэта в текущей колонке
                for (let y = 0; y < rows; y++) {
                    if (silhouetteData[y * columns + x] === 1) {
                        silhouettePositions.push(y);
                    }
                }
                
                // Если есть силуэт в этой колонке
                if (silhouettePositions.length > 0) {
                    // Перемещаем дождь вниз
                    silhouetteDrops[x] += 0.5 + Math.random() * 0.5;
                    
                    // Если капля ушла за пределы экрана, возвращаем ее наверх
                    if (silhouetteDrops[x] > rows) {
                        silhouetteDrops[x] = 0;
                    }
                    
                    // Целая часть позиции капли
                    const dropPosition = Math.floor(silhouetteDrops[x]);
                    
                    // Рисуем дождь в области силуэта
                    for (let i = 0; i < silhouettePositions.length; i++) {
                        const position = silhouettePositions[i];
                        
                        // Определяем, нужно ли рисовать падающий символ или статичный символ силуэта
                        if (position === dropPosition || 
                            (position > 0 && position === dropPosition + 1) || 
                            (position > 1 && position === dropPosition + 2)) {
                            // Падающий символ с ярко-зеленым цветом
                            silhouetteCtx.fillStyle = "#00FF00";
                            const text = silhouetteCharsArray[Math.floor(Math.random() * silhouetteCharsArray.length)];
                            silhouetteCtx.fillText(text, x * fontSize, position * fontSize);
                        }
                        else {
                            // Обычный символ силуэта, чуть темнее
                            silhouetteCtx.fillStyle = "#0C0";
                            const text = silhouetteCharsArray[Math.floor(Math.random() * silhouetteCharsArray.length)];
                            silhouetteCtx.fillText(text, x * fontSize, position * fontSize);
                        }
                    }
                }
            }
        }
        
        // Убираем старую функцию drawSilhouetteDrops, так как теперь эффект дождя интегрирован в drawSilhouette
        function drawSilhouetteDrops() {
            // Функция больше не используется
        }

        // Отрисовка матричного дождя
        function drawRain() {
            matrixCtx.fillStyle = "#0F0"; // Зеленый цвет

            for(let i = 0; i < drops.length; i++) {
                // Случайный символ
                const text = charactersArray[Math.floor(Math.random() * charactersArray.length)];

                // Рисуем символ дождя
                matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                // Возвращаем каплю наверх после прохода через экран
                if(drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                // Увеличиваем позицию капли
                drops[i]++;
            }
        }

        // Отрисовка формирования слова - теперь буквы падают сверху
        function drawForming(progress) {
            // Продолжаем дождь на фоне
            matrixCtx.fillStyle = "rgba(0, 80, 0, 0.5)"; // Тусклый зеленый

            for(let i = 0; i < drops.length; i++) {
                // Пропускаем, если эта колонка часть финальной позиции слова
                if (wordPositions.some(pos => pos.originalX === i)) {
                    continue;
                }

                const text = charactersArray[Math.floor(Math.random() * charactersArray.length)];
                matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                if(drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }

            // Отрисовка формирующихся букв с анимацией падающих сверху букв
            matrixCtx.fillStyle = "#00FF00"; // Яркий зеленый для слова

            for (let i = 0; i < wordPositions.length; i++) {
                const pos = wordPositions[i];

                // Все буквы начинаются сверху и падают вниз до своей позиции
                const currentY = Math.floor(pos.startY + (pos.originalY - pos.startY) * progress);
                
                // Добавляем эффект скорости - сначала быстро, потом замедляется
                const easeOutY = pos.startY + (pos.originalY - pos.startY) * 
                               (1 - Math.pow(1 - progress, 3)); // cubic easing out
                
                // Рисуем букву падающую сверху
                matrixCtx.fillText(pos.letter, pos.originalX * fontSize, easeOutY * fontSize);
                
                // Рисуем след из символов выше падающей буквы (эффект дождя)
                if (progress < 0.9) { // когда буква почти достигла места, перестаем рисовать след
                    const trailLength = 5; // длина следа
                    matrixCtx.fillStyle = "rgba(0, 255, 0, 0.5)"; // полупрозрачный для следа
                    
                    for (let j = 1; j <= trailLength; j++) {
                        if (easeOutY - j > 0) {
                            const trailChar = charactersArray[Math.floor(Math.random() * charactersArray.length)];
                            const trailOpacity = 0.7 - (j / trailLength * 0.6); // убывающая прозрачность
                            matrixCtx.fillStyle = `rgba(0, 255, 0, ${trailOpacity})`;
                            matrixCtx.fillText(trailChar, pos.originalX * fontSize, (easeOutY - j) * fontSize);
                        }
                    }
                    
                    matrixCtx.fillStyle = "#00FF00"; // возвращаем яркий цвет для основной буквы
                }
            }
        }

        // Отрисовка полностью сформированного слова
        function drawWord() {
            // Приглушенный фоновый дождь
            matrixCtx.fillStyle = "rgba(0, 30, 0, 0.3)"; // Очень тусклый зеленый

            for(let i = 0; i < drops.length; i++) {
                if (wordPositions.some(pos => pos.originalX === i)) {
                    continue;
                }

                const text = charactersArray[Math.floor(Math.random() * charactersArray.length)];
                matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                if(drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }

            // Рисуем слово с эффектом свечения
            matrixCtx.fillStyle = "#00FF00"; // Зеленый
            for (let i = 0; i < wordPositions.length; i++) {
                const pos = wordPositions[i];
                matrixCtx.fillText(pos.letter, pos.originalX * fontSize, pos.originalY * fontSize);
            }
        }

        // Отрисовка растворения слова обратно в дождь
        function drawDissolving(progress) {
            // Постепенно возвращаем полный дождь
            matrixCtx.fillStyle = "rgba(0, " + Math.floor(80 + 175 * progress) + ", 0, 0.5)";

            for(let i = 0; i < drops.length; i++) {
                const text = charactersArray[Math.floor(Math.random() * charactersArray.length)];

                // Если здесь была буква, постепенно заменяем её
                const wordLetter = wordPositions.find(pos => pos.originalX === i);
                if (wordLetter && Math.random() > progress) {
                    // Все еще показываем букву с уменьшающейся вероятностью
                    matrixCtx.fillStyle = "rgba(0, 255, 0, " + (1 - progress) + ")";
                    matrixCtx.fillText(wordLetter.letter, i * fontSize, wordLetter.originalY * fontSize);
                    matrixCtx.fillStyle = "rgba(0, " + Math.floor(80 + 175 * progress) + ", 0, 0.5)";
                } else {
                    // Обычный символ дождя
                    matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);
                }

                if(drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }
        }

        // Обработчик изменения размера окна
        window.addEventListener('resize', function() {
            matrixCanvas.width = videoCanvas.width = silhouetteCanvas.width = window.innerWidth;
            matrixCanvas.height = videoCanvas.height = silhouetteCanvas.height = window.innerHeight;

            // Пересчитываем количество столбцов и строк
            const newColumns = Math.ceil(matrixCanvas.width/fontSize);
            const newRows = Math.ceil(matrixCanvas.height/fontSize);

            // Обновляем массивы, если изменилось количество столбцов
            if (newColumns !== columns) {
                // Обновляем капли
                const newDrops = [];
                for(let x = 0; x < newColumns; x++) {
                    if (x < drops.length) {
                        newDrops[x] = drops[x];
                    } else {
                        newDrops[x] = 1;
                    }
                }
                drops = newDrops;
                
                // Обновляем силуэтные капли
                const newSilhouetteDrops = [];
                for(let x = 0; x < newColumns; x++) {
                    if (x < silhouetteDrops.length) {
                        newSilhouetteDrops[x] = silhouetteDrops[x];
                    } else {
                        newSilhouetteDrops[x] = 0;
                    }
                }
                silhouetteDrops = newSilhouetteDrops;

                // Обновляем силуэт
                if (cameraActive) {
                    silhouetteData = new Uint8Array(newColumns * newRows);
                    silhouetteMatrix = Array(newRows * newColumns).fill(null);
                }
            }

            if (mode !== "rain") {
                calculateWordPositions();
            }
        });

        // Запускаем анимацию
        setInterval(draw, 33); // ~30fps
        </script>
    </body>
</html>
